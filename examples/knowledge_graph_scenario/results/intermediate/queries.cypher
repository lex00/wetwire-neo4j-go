// Common Graph Queries for Academic Paper Knowledge Graph
// Generated by wetwire-neo4j-go

// ============================================
// BASIC RETRIEVAL QUERIES
// ============================================

// Find all papers by a specific author
MATCH (p:Person)-[:AUTHORED]->(d:Document)
WHERE p.name = $authorName
RETURN d.id, d.title, d.year, d.abstract
ORDER BY d.year DESC;

// Find all papers from a specific institution
MATCH (i:Institution)<-[:AFFILIATED_WITH]-(p:Person)-[:AUTHORED]->(d:Document)
WHERE i.name = $institutionName
RETURN d.id, d.title, d.year, p.name as author
ORDER BY d.year DESC;

// Find all papers studying a specific concept
MATCH (d:Document)-[:STUDIES]->(c:Concept)
WHERE c.name = $conceptName
RETURN d.id, d.title, d.year, d.abstract
ORDER BY d.year DESC;

// ============================================
// CITATION NETWORK QUERIES
// ============================================

// Find direct citations of a paper
MATCH (d1:Document)-[r:CITES]->(d2:Document)
WHERE d1.id = $documentId
RETURN d2.id, d2.title, d2.year, r.citedYear
ORDER BY d2.year DESC;

// Find papers that cite a given paper (reverse citations)
MATCH (d1:Document)-[r:CITES]->(d2:Document)
WHERE d2.id = $documentId
RETURN d1.id, d1.title, d1.year, r.citedYear
ORDER BY d1.year DESC;

// Find citation chain (1-3 hops)
MATCH path = (d1:Document)-[:CITES*1..3]->(d2:Document)
WHERE d1.id = $documentId
RETURN path
LIMIT 100;

// Find common citations between two papers
MATCH (d1:Document)-[:CITES]->(shared:Document)<-[:CITES]-(d2:Document)
WHERE d1.id = $documentId1 AND d2.id = $documentId2
RETURN shared.id, shared.title, shared.year
ORDER BY shared.year DESC;

// ============================================
// COLLABORATION QUERIES
// ============================================

// Find co-authors of a person
MATCH (p1:Person)-[:AUTHORED]->(d:Document)<-[:AUTHORED]-(p2:Person)
WHERE p1.id = $personId AND p1 <> p2
RETURN DISTINCT p2.id, p2.name, count(d) as collaborations
ORDER BY collaborations DESC;

// Find co-author network (2 hops)
MATCH path = (p1:Person)-[:AUTHORED]->(:Document)<-[:AUTHORED]-(p2:Person)-[:AUTHORED]->(:Document)<-[:AUTHORED]-(p3:Person)
WHERE p1.id = $personId AND p1 <> p2 AND p2 <> p3 AND p1 <> p3
RETURN DISTINCT p3.id, p3.name, length(path) as distance
LIMIT 50;

// Find most collaborative institutions
MATCH (i1:Institution)<-[:AFFILIATED_WITH]-(p1:Person)-[:AUTHORED]->(d:Document)<-[:AUTHORED]-(p2:Person)-[:AFFILIATED_WITH]->(i2:Institution)
WHERE i1.id = $institutionId AND i1 <> i2
RETURN i2.id, i2.name, count(DISTINCT d) as jointPapers
ORDER BY jointPapers DESC;

// ============================================
// CONCEPT AND TOPIC QUERIES
// ============================================

// Find related concepts (co-studied in same papers)
MATCH (c1:Concept)<-[:STUDIES]-(d:Document)-[:STUDIES]->(c2:Concept)
WHERE c1.id = $conceptId AND c1 <> c2
RETURN c2.id, c2.name, count(d) as coOccurrences
ORDER BY coOccurrences DESC
LIMIT 20;

// Find trending concepts by year
MATCH (d:Document)-[:STUDIES]->(c:Concept)
WHERE d.year = $year
RETURN c.id, c.name, count(d) as frequency
ORDER BY frequency DESC
LIMIT 20;

// Find authors working on a specific concept
MATCH (p:Person)-[:AUTHORED]->(d:Document)-[:STUDIES]->(c:Concept)
WHERE c.id = $conceptId
RETURN p.id, p.name, count(DISTINCT d) as papers
ORDER BY papers DESC
LIMIT 20;

// ============================================
// HYBRID SEARCH QUERIES
// ============================================

// Vector similarity search for documents
CALL db.index.vector.queryNodes('document_embedding', $topK, $queryEmbedding)
YIELD node, score
RETURN node.id, node.title, node.abstract, score
ORDER BY score DESC;

// Fulltext search on documents
CALL db.index.fulltext.queryNodes('document_content', $searchQuery)
YIELD node, score
RETURN node.id, node.title, node.abstract, score
ORDER BY score DESC
LIMIT $limit;

// Hybrid search combining vector and fulltext
CALL {
  CALL db.index.vector.queryNodes('document_embedding', 20, $queryEmbedding)
  YIELD node, score
  RETURN node, score * 0.6 as finalScore
  UNION
  CALL db.index.fulltext.queryNodes('document_content', $searchQuery)
  YIELD node, score
  RETURN node, score * 0.4 as finalScore
}
WITH node, sum(finalScore) as combinedScore
RETURN node.id, node.title, node.abstract, combinedScore
ORDER BY combinedScore DESC
LIMIT $topK;

// ============================================
// ANALYTICS QUERIES
// ============================================

// Most cited papers
MATCH (d:Document)
OPTIONAL MATCH (citing:Document)-[:CITES]->(d)
WITH d, count(citing) as citationCount
WHERE citationCount > 0
RETURN d.id, d.title, d.year, citationCount
ORDER BY citationCount DESC
LIMIT 50;

// Most prolific authors
MATCH (p:Person)-[:AUTHORED]->(d:Document)
RETURN p.id, p.name, count(d) as paperCount
ORDER BY paperCount DESC
LIMIT 50;

// Most studied concepts
MATCH (c:Concept)<-[:STUDIES]-(d:Document)
RETURN c.id, c.name, c.category, count(d) as frequency
ORDER BY frequency DESC
LIMIT 50;

// Institution productivity
MATCH (i:Institution)<-[:AFFILIATED_WITH]-(p:Person)-[:AUTHORED]->(d:Document)
RETURN i.id, i.name, count(DISTINCT d) as papers, count(DISTINCT p) as authors
ORDER BY papers DESC
LIMIT 50;

// Research output by year
MATCH (d:Document)
WHERE d.year IS NOT NULL
RETURN d.year, count(d) as paperCount
ORDER BY d.year DESC;

// ============================================
// RECOMMENDATION QUERIES
// ============================================

// Recommend papers based on citation patterns
MATCH (d1:Document)-[:CITES]->(cited:Document)<-[:CITES]-(d2:Document)
WHERE d1.id = $documentId AND d1 <> d2
WITH d2, count(cited) as commonCitations
RETURN d2.id, d2.title, d2.year, commonCitations
ORDER BY commonCitations DESC
LIMIT 10;

// Recommend authors based on similar research interests
MATCH (p1:Person)-[:AUTHORED]->(d1:Document)-[:STUDIES]->(c:Concept)<-[:STUDIES]-(d2:Document)<-[:AUTHORED]-(p2:Person)
WHERE p1.id = $personId AND p1 <> p2
WITH p2, collect(DISTINCT c.name) as sharedConcepts, count(DISTINCT c) as conceptOverlap
RETURN p2.id, p2.name, conceptOverlap, sharedConcepts
ORDER BY conceptOverlap DESC
LIMIT 10;

// Recommend concepts to explore based on current research
MATCH (p:Person)-[:AUTHORED]->(d1:Document)-[:STUDIES]->(c1:Concept)
WHERE p.id = $personId
WITH collect(DISTINCT c1) as currentConcepts
MATCH (d2:Document)-[:STUDIES]->(c1)-[:STUDIES]-(d2)-[:STUDIES]->(c2:Concept)
WHERE c1 IN currentConcepts AND NOT c2 IN currentConcepts
RETURN c2.id, c2.name, count(DISTINCT d2) as relevance
ORDER BY relevance DESC
LIMIT 10;
